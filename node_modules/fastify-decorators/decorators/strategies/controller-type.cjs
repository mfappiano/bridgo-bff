'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var controllerType = require('../../registry/controller-type.cjs');
var index = require('../../symbols/index.cjs');
var classProperties = require('../helpers/class-properties.cjs');
var createErrorsHandler = require('../helpers/create-errors-handler.cjs');
var swaggerHelper = require('../helpers/swagger-helper.cjs');

/**
 * @license
 * Copyright Andrey Chalkin <L2jLiga@gmail.com> (https://github.com/L2jLiga). All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/L2jLiga/fastify-decorators/blob/master/LICENSE
 */
function targetFactory(constructor, classLoader) {
    return function getTarget(request) {
        return classLoader(constructor, request);
    };
}
/**
 * Various strategies which can be applied to controller
 *
 * @usageNotes
 *
 * There are few available strategies:
 *   SINGLETON strategy creates one instance of controller which will handle all requests
 *   REQUEST strategy will create new instance for each request/hook
 *
 * By default controllers use SINGLETON strategy
 */
const ControllerTypeStrategies = {
    [controllerType.ControllerType.SINGLETON](instance, constructor, classLoader, tags) {
        if (tags.length > 0)
            swaggerHelper.injectTagsIntoSwagger(instance, tags);
        const controllerInstance = classLoader(constructor);
        if (classProperties.hasHandlers(constructor))
            registerHandlers(constructor[index.HANDLERS], instance, controllerInstance, tags);
        if (classProperties.hasErrorHandlers(constructor))
            registerErrorHandlers(constructor[index.ERROR_HANDLERS], instance, controllerInstance);
        if (classProperties.hasHooks(constructor))
            registerHooks(constructor[index.HOOKS], instance, controllerInstance);
        return controllerInstance;
    },
    [controllerType.ControllerType.REQUEST](instance, constructor, classLoader, tags) {
        if (tags.length > 0)
            swaggerHelper.injectTagsIntoSwagger(instance, tags);
        const getTarget = targetFactory(constructor, classLoader);
        if (classProperties.hasHandlers(constructor))
            for (const handler of constructor[index.HANDLERS]) {
                const { url, method, handlerMethod, options } = handler;
                instance[method](url, tags.length > 0 ? { ...options, schema: { tags: tags.map((tag) => tag.name), ...options.schema } } : options, function (request, ...args) {
                    return getTarget(request)[handlerMethod](request, ...args);
                });
            }
        if (classProperties.hasErrorHandlers(constructor))
            instance.setErrorHandler((error, request, ...rest) => {
                const errorsHandler = createErrorsHandler.createErrorsHandler(constructor[index.ERROR_HANDLERS], getTarget(request));
                return errorsHandler(error, request, ...rest);
            });
        if (classProperties.hasHooks(constructor))
            for (const hook of constructor[index.HOOKS]) {
                instance.addHook(hook.name, (request, ...rest) => {
                    return getTarget(request)[hook.handlerName](request, ...rest);
                });
            }
    },
};
function registerHandlers(handlers, instance, controllerInstance, tags) {
    for (const handler of handlers) {
        instance[handler.method](handler.url, tags.length > 0 ? { ...handler.options, schema: { tags: tags.map((it) => it.name), ...handler.options.schema } } : handler.options, (...args) => controllerInstance[handler.handlerMethod](...args));
    }
}
function registerHooks(hooks, instance, controllerInstance) {
    for (const hook of hooks) {
        instance.addHook(hook.name, controllerInstance[hook.handlerName].bind(controllerInstance));
    }
}
function registerErrorHandlers(errorHandlers, instance, classInstance) {
    instance.setErrorHandler(createErrorsHandler.createErrorsHandler(errorHandlers, classInstance));
}

exports.ControllerTypeStrategies = ControllerTypeStrategies;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbbnVsbF0sInNvdXJjZXNDb250ZW50IjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFtQztBQUNoRSxvQkFBb0IseUJBQXdCO0FBQzVDLDhCQUE4QixpQ0FBZ0M7QUFDOUQsa0NBQWtDLHNDQUFxQztBQUN2RSw0QkFBNEIsK0JBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyJ9

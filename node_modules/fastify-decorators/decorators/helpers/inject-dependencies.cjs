'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('../../symbols/index.cjs');
var classProperties = require('./class-properties.cjs');
var dependencyScope = require('./dependency-scope.cjs');

/**
 * @license
 * Copyright Andrey Chalkin <L2jLiga@gmail.com> (https://github.com/L2jLiga). All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/L2jLiga/fastify-decorators/blob/master/LICENSE
 */
function classLoaderFactory(injectables) {
    function classLoader(constructor, scope) {
        scope = scope || dependencyScope.defaultScope;
        if (dependencyScope.dependencyScopeManager.has(scope, constructor))
            return dependencyScope.dependencyScopeManager.get(scope, constructor);
        /**
         * Step 1: Patch constructor and prototype with Injectables (issue #752)
         */
        injectProperties(constructor, constructor, injectables, classLoader, constructor.name);
        injectProperties(constructor.prototype, constructor.prototype, injectables, classLoader, constructor.name);
        /**
         * Step 2: Create instance
         */
        const instance = typeof Reflect.getMetadata === 'function' ? new constructor(...getArguments(constructor, injectables, classLoader, constructor.name)) : new constructor();
        /**
         * Step 3: Inject dependencies into instance (issue #750)
         */
        injectProperties(instance, constructor.prototype, injectables, classLoader, constructor.name);
        /**
         * Step 4: Optionally store instance in Map if cache enabled
         */
        dependencyScope.dependencyScopeManager.add(scope, constructor, instance);
        /**
         * Step 4: Return instance with dependencies injected
         */
        return instance;
    }
    return Object.assign(classLoader, {
        reset(scope) {
            dependencyScope.dependencyScopeManager.clear(scope);
        },
    });
}
function injectProperties(target, source, injectables, classLoader, className) {
    if (!classProperties.hasServiceInjection(source))
        return;
    const viaInject = source[index.SERVICE_INJECTION];
    for (const { name, propertyKey } of viaInject) {
        if (!injectables.has(name))
            throw new TypeError(`Invalid argument provided for "${className}.${String(propertyKey)}". Expected class annotated with @Service.`);
        Object.defineProperty(target, propertyKey, {
            // @ts-expect-error we already have checked that injectables list has this entry, no needs to nullish coalescing and so on
            value: injectables.get(name)[index.CREATOR].register(classLoader),
            enumerable: true,
            configurable: true,
        });
    }
}
function getArguments(constructor, injectables, classLoader, className) {
    const metadata = Reflect.getMetadata('design:paramtypes', constructor) || [];
    return metadata
        .map((value) => injectables.get(value))
        .map((value) => {
        if (value)
            return value[index.CREATOR].register(classLoader);
        throw new TypeError(`Invalid argument provided in ${className}'s constructor. Expected class annotated with @Service.`);
    });
}

exports.classLoaderFactory = classLoaderFactory;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbbnVsbF0sInNvdXJjZXNDb250ZW50IjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF3QjtBQUM1Qyw4QkFBOEIsd0JBQXVCO0FBQ3JELDhCQUE4Qix3QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsifQ==
